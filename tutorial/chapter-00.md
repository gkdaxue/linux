# 计算机存储设备(机械硬盘)

## 物理组成

硬盘是由很多的盘片, 机械手臂, 磁头以及转轴马达所组成的,内部结构如图0-0所示
![机械硬盘物理构造](https://github.com/gkdaxue/linux/raw/master/image/chapter_00.png)

机械手臂构造如图0-1所示
![机械手臂构造](https://github.com/gkdaxue/linux/raw/master/image/chapter_01.png)

## 工作原理

    主轴马达带动盘片转动,然后机械手臂可伸展让磁头(读取头)在盘片上进行读写操作,读写主要通过机械臂上的读取头来操作,而实际的数据就是写在具有磁性物质的盘片上,单一的盘片容量有限, 因此有些容量比较大的硬盘会有很多盘片.

## 物理结构

    磁盘的物理结构如图0-2所示
![磁盘物理结构分析](https://github.com/gkdaxue/linux/raw/master/image/chapter_02.png)    

### 盘片(Platter)

    一块硬盘有若干盘片，每个盘片有可以存储数据的上、下两盘面/磁面(Side), 这些盘面堆叠在主轴上高速旋转，它们从上至下从“0”开始依次编号

### 磁头(Head)

    每个盘片的每个有效的盘面都会有一个磁头(Read/Write head), `磁头数 = 盘面数 = 盘片个数 * 2` . 由于磁头工作的性质，对磁感应的要求非常高。磁头是在高速旋转的盘片上悬浮的，悬浮力来自盘片旋转带动的气流，磁头必须悬浮而不是接触盘面，避免盘面和磁头发生相互接触造成磨损

### 磁道(Track)

    当盘片旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道.(磁道是一个同心圆环而不是一个同心圆,为了方便描述, 所以画成了圆环,扇区组成一个圆就是磁道) **磁道从外向内从0开始顺序编号**

### 扇区(Sector)

    将一个盘面划分为若干内角相同的扇形，这样盘面上的每个磁道就被分为若干段圆弧，每段圆弧叫做一个扇区(外围磁道上的扇区数量要大于内圈的磁道,所以数据的读写默认是由外圈往内圈操作).每个扇区可以存放512个字节的信息.（相邻两个磁道或扇区之间都留有一定间隙，以避免精度问题造成故障） **磁盘的最小物理存储单位**

### 柱面(Cylinder)

    每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘单面上的磁道数是相等的。无论是双盘面还是单盘面，由于每个盘面都只有自己独一无二的磁头，因此，盘面数等于总的磁头数.所谓硬盘的CHS，即Cylinder（柱面）、Head（磁头）、Sector（扇区），只要知道了硬盘的CHS的数目，即可确定硬盘的容量，硬盘的容量=柱面数*磁头数*扇区数*512B.     **分区的最小单位**

## 磁盘传输接口

    目前磁盘与主机系统的连接主要有 `IDE接口` `SATA接口` `SCSI接口` 这三种传输接口规格

## 注意事项

    在GPT模式下,磁盘的分区通常使用`扇区号码`来划分, 而在MS-DOS中则是通过`柱面号码`来划分的(先做了解)

# Linux是什么

    Linux就是一个操作系统, 就是内核(Kernel)与系统调用(System Call)那两层. 操作系统知识在管理整个硬件信息, 包含CPU, 内存, 输入输出设备及系统文件等. 如图0-3所示
![操作系统的角色](https://github.com/gkdaxue/linux/raw/master/image/chapter_03.png)  

## 内核(Kernel)

    管理计算机的所有活动以及驱动系统中的所有硬件, 管理硬件以及提供合理的计算机系统资源分配(CPU, 内存等). (只有内核提供的功能, 你的系统才能帮你完成)    

    内核的功能主要有: `提供系统调用接口` `程序管理` `内存管理` `文件系统管理` `设备驱动`等 

### 内核版本

    内核也是软件, 所以也是在不断的升级中, 所以也是有不同的版本. 可以通过 `uname -r` 命令来进行查看.  如 `2.6.32-696.el6.x86_64`
    表示的含义为 : **主版本.次版本.发布版本-修订版本.操作系统版本(el6 Centos 6).CPU架构(64位)**

```
    主次版本为奇数 : 开发中版本(development)
    主次版本为偶数 : 稳定版本(stable)
```

## 系统调用(System Call)

    为了保护内核, 操作系统通常会提供一整组开发接口. 应用程序则是根据操作系统提供的开发接口来运行的. 由此可见软件/硬件都与内核有很大的关系, 而与用户相关的则是应用程序了. 

## 硬件设备命令规则

    在Linux中有一个很重要的概念 : ` Linux系统中, 一切皆文件` , 那么都是文件, 系统是怎么识别哪些文件是硬盘, 鼠标这些呢, 这就需要用到我们讲解的命名规则, 举例来说 : `SATA接口的硬盘文件名为/dev/sd[a-p]`, **几乎所有的硬件设备文件都在/dev这个目录中**

> `[a-p]` : 中括号中 a-p 表示 a-p 当中的任意一个,  如/dev/sda, /dev/sdb, /dev/sdc 等

| 设备                        | Linux中的文件名                                                                       |
|:------------------------- |:-------------------------------------------------------------------------------- |
| IDE 硬盘                    | /dev/hd\[a-d\]                                                                   |
| SCSI / SATA / USB 硬盘 / U盘 | /dev/sd\[a-p\]                                                                   |
| Virtio 接口                 | /dev/vd\[a-p\]                                                                   |
| 软盘驱动器                     | /dev/fd\[0-7\]                                                                   |
| 打印机                       | /dev/lp\[0-2\] (25针打印机)<br>/dev/usb/lp\[0-15\] (USB接口)                           |
| 鼠标                        | /dev/psaux (ps/2接口)<br>/dev/usd/mouse\[0-15\] (USB)<br>/dev/mouse (当前鼠标)         |
| CD/DVD ROM                | /dev/cdrom (当前cd-rom) <br>/dev/sr\[0-1\] (通用 CentOS较常见) <br>/dev/scd\[0-1\] (通用) |
| 磁带机                       | /dev/ht0 (IDE接口)<br>/dev/st0 (SATA/SCSI接口)<br>/dev/tape (当前磁带)                   |

<center>表 0-0 Linux中硬件设备命名规则</center>

# 磁盘分区

    一个硬盘可以被分为多个分区(partition),  从window角度来看, 我们都知道可以分为C D E F 盘等等, 系统一般装在C盘, 但是`在Linux系统中一切皆文件` 那么分区的文件名是什么, 又该如何表示, 系统装在什么地方, 这就是我们接下来要讲解的重点.

个人计算机常见的磁盘接口为 `IDE` 和 `SATA` 这两种接口, 主流接口为`SATA接口` , 而我们从表 0-0 中可以知道 SATA 接口在Linux中设备名为 /dev/sd\[a-p\]这种形式, 那么如果我有两块硬盘 都插在了 SATA 接口中, 那么每个硬盘又是如何命名的呢?

> SATA / USB 接口的磁盘设备文件名根本就没有一定的顺序,  而是根据 **`Linux内核检测到磁盘的顺序来决定设备的文件名`** 

```
比如我有两块SATA硬盘以及一个USB磁盘, 主板上面有六个SATA插槽,而SATA被插在SATA1, SATA5插槽上, 那么这三个磁盘在Linux中的设备文件名分别是什么?

因为是根据检测到的顺序来对文件命名而不是实际插槽的顺序,由此可得
1. SATA1插槽 : /dev/sda
2. SATA5插槽 : /dev/sdb  (而不是/dev/sde,虽然在第5个插槽上, 但是是根据识别到的顺序)
3. USB磁盘   : /dev/sdc (开机完成后才被系统识别到)
```

## 磁盘的组成

    磁盘主要由盘片, 机械臂, 磁头, 转轴马达组成.  盘片可以细分为 扇区(Sector) 和 柱面(Cylinder) 两种单位, 其中每个扇区为 512bytes(字节) 大小, `整块硬盘的第一个扇区最重要, 它包含了以下两个重要信息`  

- **主引导分区(Master Boot Record, MBR)** : 可以安装引导加载程序的地方, 有 446bytes .

- **分区表(Partition Table)** : 记录整块硬盘分区的状态, 有 64bytes

    MBR 是很重要的, 因为系统在开机的时候会主动去读取这个区块的内容, 这样系统才能知道程序放在什么地方且应该如何开机, 如果需要安装多重引导的系统, 那么这个MBR 区块的管理就非常重要了.  分区表就像一张图纸, 只有有图纸了, 才知道如何在上面盖房子(写数据).

## 磁盘分区表( partition table )

    就第一个扇区来讲，共512字节, 其中主引导记录需要占用446字节，分区表为64字节，结束符占用2字节；分区表中每记录一个分区信息就需要16字节，这样一来最多只有4个分区信息可以写到第一个扇区中，每个分区记录了该区段的起始与结束的柱面号码, 所以磁盘中最多也就4个主分区, 而且硬盘的分区编号也很有讲究. 如下所示:

> 主分区或扩展分区的编号从1开始，到4结束
> 
> 逻辑分区从编号5开始

![第一个扇区中的数据信息](https://github.com/gkdaxue/linux/raw/master/image/chapter_04.png)<br>
    `由于分区表只有 64字节, 最多只能容纳四个分区`, 这四个分区被称为主(Primary)或扩展(Extended)分区,  那么是不是表示我的一块硬盘最多只能分四个区呢, 当然不是, 这就要通过我们说的扩展分区来解决更多的分区需求.

> **`扩展分区本身并不能被用来格式化`**
> 
> 扩展分区的目的是利用更多的扇区来记录分区的信息, 更像一个指针一样指向另外一个分区.  扩展分区，严格地讲它不是一个实际意义的分区，它仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。

    然后我们就可以在扩展分区上继续新建 `逻辑分区(logical partition)` 来达到我们更多分区的需求. (`逻辑分区是由扩展分区划分出来的, 所以逻辑分区可以使用的柱面范围也就是扩展分区所设定的范围`),  一般会选择使用3个主分区加1个扩展分区的方法，然后在扩展分区中创建出数个逻辑分区，从而来满足多分区（大于4个）的需求.  如图 0-5 所示:
![硬盘分区的规划](https://github.com/gkdaxue/linux/raw/master/image/chapter_05.png)<br>

    假设我现在有一个 SCSI硬盘设备, 系统识别为/dev/sda,   按照 图 0-5 划分好了分区信息,  现在我们来分析一下 图 0-5 的信息, 以及各个分区的设备文件名.

> 图中有两个主分区, 一个扩展分区, 两个逻辑分区, 在结合我们之前所说的信息
> 
> 1. 主分区或扩展分区的编号从1开始，到4结束
> 
> 2. 逻辑分区从编号5开始
> 
> 3. 逻辑分区是在扩展分区的基础上进行的分区操作
> 
> 所以设备文件名命名的顺序应该是  `主分区 -> 扩展分区 -> 逻辑分区 `
> 
> 第一个主分区 : /dev/sda1
> 
> 第二个主分区 : /dev/sda2
> 
> 扩展分区 : /dev/sda3 (绿色部分)
> 
> 第一个逻辑分区 : /dev/sda5 (为啥是5呢? 请自己独立分析)
> 
> 第二个逻辑分区 : /dev/sda6

    如果有一个 /dev/sda3 的设备文件名, 是否表示已经有了3个分区呢 ?   其实这是不对的, 因为`分区号码也是可以手动指定的`, 所以/dev/sda3只能表示是编号为3的分区，而不能判断/dev/sda设备上已经存在了3个分区。那么我们来分析一下 `/dev/sda5` 的意思.

> /dev : 设备文件的保存目录, 里面保存的都是设备文件
> 
> sd    : 表示的是存储设备, 可以是 SCSI / SATA 等等
> 
> a      : 第一个被内核识别到的设备
> 
> 5      : 表示是一个逻辑分区
> 
> 总结 : 系统中第一个块被识别到的硬件设备中分区编号为5的逻辑分区设备文件 

## 分区的必要性

我们为什么一定要分区呢? 主要有以下几点:

- 数据的安全性 : 分区的数据是分开的, 如果一个分区损坏导致数据丢失, 也只会丢失一个分区的数据, 不会影响到其他分区的数据, 最常见的就是我们在Window中把系统装在C盘, 然后资料放在其他盘, 这样我们重装系统, 主要把C盘格式化重新安装即可, 不会影响到我们资料的安全.

- 数据的读写性能 : 因为记录了对应分区的柱面号码, 直接从柱面起始号码搜索数据即可, 不用每次都要全盘搜索.

## 总结

关于主分区, 扩展分区和逻辑分区总结如下 :

- 主分区和扩展分区最多只能有4个(硬盘限制)

- 扩展分区最多只能有一个(操作系统限制)

- 逻辑分区是由扩展分区持续切割出来的分区 (`如果扩展分区被删除, 那么逻辑分区以及逻辑分区中的所有数据也会被删除`)

- 只有主分区和逻辑分区可以被格式化以及存放数据, 扩展分区无法格式化

## 练习题

### 习题一

    我现在有一块 256G 的 SATA 硬盘, 会被系统识别为 /dev/sda,  暂时只想分为4个分区, 每个分区大小为40G, 剩余的空间以后在规划, 然后你会怎么进行规划? (合理即可) 分区的设备文件名又是什么?

> 1. 4个主分区  (不合适, 剩余的空间无法被利用.)
> 
> 2. 分区暂时为4个, 以后在划分, 所以表示一定会有扩展分区的存在,  所以我们可以给出 `P + P + P + E + L`, 并且`在创建扩展分区时, 一定要把所有剩余的空间全部分为扩展分区(为什么? 想一下原因)`, 然后在扩展分区上在划分出逻辑分区即可
> 
> 3. 也有其他方式 比如 `P + P + E + L + L` 都可以, 合理即可
> 
> 4. P : 主分区 (Primary)       E : 扩展分区  (Extend)     L : 逻辑分区(Logical)

    我们把一个硬盘的柱面拆开如 图0-6 所示,  然后我们来讲解按照 1 和 2 情况下, 磁盘的使用情况
![磁盘分区表的作用示意图](https://github.com/gkdaxue/linux/raw/master/image/chapter_06.png)<br>

> **P + P + P + P 组合** : (400 - 500 剩余空间无法使用, 因为一块硬盘 `主分区和扩展分区最多只能有4个` 不能划分逻辑分区, 自然无法利用)
> 
>     主分区 : /dev/sda1 : 1 - 100    
>     
>     主分区 : /dev/sda2 : 100 - 200
>     
>     主分区 : /dev/sda3 : 200 - 300
>     
>     主分区 : /dev/sda4 : 300 - 400
> 
> **P + P + P + E + L  组合** : (400 - 500 剩余空间可以继续使用)
> 
>     主分区 : /dev/sda1 : 1 - 100
>     
>     主分区 : /dev/sda2 : 100 - 200
>     
>     主分区 : /dev/sda3 : 200 - 300
>     
>     扩展分区 : /dev/sda4 : 300 - 500 (为什么是300-500, 自己思考一下)
>     
>     逻辑分区 : /dev/sda5 : 300 - 400  

### 习题二

    在习题一的基础上我们又划出了一个分区 /dev/sda6 , 那么 /dev/sda6 能否和 /dev/sda2 整合成一个新分区,  和 /dev/sda5 又是否可以呢?

> **/dev/sda5 和 /dev/sda6** :
> 
>     两个都属于逻辑分区, 所以只要将这两个分区删除(**先把分区资料迁移到其他分区**),在重新创建一个分区即可. 能够在不影响其他分区的情况下整合成一个.
> 
> **/dev/sda2 和 /dev/sda6** :
> 
>     一个是主分区, 一个是逻辑分区, 两者不能整合, 除非把扩展分区破坏掉在重新分区, 但是这会影响到所有的逻辑分区.(**扩展分区被破坏, 所有的逻辑分区也将被删除**) 这个代价太大了, 所以一般是不能整合

## 开机流程与MBR(了解即可)

        主板上面有 **BIOS** 和 **CMOS** 这两个东西, CMOS 记录各项硬件参数并嵌入到主板上面的存储器, BIOS 则是一个写入到主板上的一个软件程序, 在系统开机时主动执行的第一个程序. 所以在开机时, 先执行 BIOS 程序, 然后 BIOS 会根据用户的设置去取得能够开机的硬盘(装过系统的同学, 使用U盘安装系统时, 要更改启动项的顺序, 选择U盘启动), 然后去该硬盘里面读取第一个扇区的 MBR 位置, MBR 只有 446字节 里面存放这最基本的引导加载程序, 然后就是 MBR 内的引导和加载工作了, 引导加载的目的是加载 内核(kernel, 也就是我们说的操作系统的kernel), 这个引导加载程序是在安装操作系统是提供的, 所以它能够识别硬盘内的文件格式, 所以就能够读取内核文件, 然后接下来就是内核文件的工作了. 总结来说是一下几点:

1. BIOS : 开机第一个执行的程序, 负责找到设置中对应的硬盘

2. MBR : 第一个扇区中的主引导程序, 包含了引导加载程序

3. 引导加载程序(Boot Loader) : 可读取内核文件来执行的软件

      Boot Loader 的主要任务 :

   1.  提供菜单 : 可以选择不同的开机选项

   2. 载入内核文件 : 直接指向可开机的程序区段来开始操作系统

   3. 转交其他loader : 将引导加载功能转交给其他loader(多重引导的功能)

      > 引导加载程序除了可以安装在MBR之外, 还可以安装在每个分区的 引导扇区(boot ) ,  所以才有多重引导的功能

4. 内核文件(kernel) : 开始操作系统的启动工作




